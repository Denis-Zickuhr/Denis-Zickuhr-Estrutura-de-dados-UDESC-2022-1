public List<Estado> sucessores() {

		List<Estado> suc = new ArrayList<Estado>();

		Collection<Integer> a = List.of(1,2,3,4);
		int r = 0;
		for (String[] s: movimentosValidos
			 ) {
			for (String s1: s
			) {
				if (Integer.parseInt(s1) >= 2 & Integer.parseInt(s1) <= 3)
					r += 1;
			}
		}


		permute(new int[]{1, 2});

		CharSequence cs;
		int count = 0;
		for (int i = 0; i < Math.pow(2, 16); i++) {
			cs = padLeft(Integer.toBinaryString(i),16, '0');
			if (ordemBlocos.chars().average().equals(cs.chars().average())){
				String str = cs.toString().replaceAll("1", "#");

				for (int last = 0; last < list.size(); last++) {
					String strCopy = str;
					for (int j = 0; j < list.get(last).toString().length(); j++) {
						strCopy = strCopy.replaceFirst("#", list.get(last).toString().charAt(j) + "");
					}

					// Aqui montamos a versão nova desses objetos para o movimento X

					//System.out.println(str);

					String[][] puzzleCopy = puzzleCopy(this.puzzle); // Precisa ser copiado manualmente!
					String[][] movimentosValidosCopy = puzzleCopy(movimentosValidos); // Precisa ser copiado manualmente!
					String ordemBlocosCopy = ordemBlocos;

					// Aqui montamos a versão nova desses objetos para o movimento X


					List<Collection<Integer>> result = Collections.nCopies(1, Collections.emptyList());
					for (Collection<Integer> pool : Collections.nCopies(r, new LinkedHashSet<>(a))) {
						List<Collection<Integer>> temp = new ArrayList<>();
						for (Collection<Integer> x : result) {
							for (Integer elemento : pool) {
								Collection<Integer> z = new ArrayList<>(x);
								z.add(elemento);
								temp.add(z);
								// A partir daqui, é gerado um sucessor de diferente ordenação de tubos
								if (z.size() == r) {
									String[][] movimentosValidosTurno = puzzleCopy(movimentosValidos); // Precisa ser copiado manualmente!
									for (Integer k : z) {
										boolean next = true;
										for (int v = 0; v < 4 & next; v++) {
											for (int j = 0; j < 4 & next; j++) {
												if (Integer.parseInt(movimentosValidosTurno[v][j]) >= 2 & Integer.parseInt(movimentosValidosTurno[v][j]) <= 3) {
													movimentosValidosTurno[v][j] = "0"; // Indica que a peça já foi movimentada nessa rodada
													puzzleCopy[v][j] = rotateBlock(puzzleCopy[v][j], k);
													next = false; // Faz a quebra do laço
												}
											}
										}
									}
									Teste sucessor = new Teste(puzzleCopy, movimentosValidosCopy, ordemBlocosCopy);
									suc.add(sucessor);
									count++;
									break;
								}
							}
							break;
						}
						result = temp;
					}
				}
			}
		}
		//System.out.println(count);
		return suc;
	}