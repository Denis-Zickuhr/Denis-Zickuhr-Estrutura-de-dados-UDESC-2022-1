public List<Estado> sucessores() {

		List<Estado> suc = new ArrayList<Estado>();

		Collection<Integer> a = List.of(1,2,3,4);
		int r = 0;
		for (String[] s: movimentosValidos
			 ) {
			for (String s1: s
			) {
				if (Integer.parseInt(s1) >= 2 & Integer.parseInt(s1) <= 3)
					r += 1;
			}
		}


		permute(new int[]{1, 2});

		CharSequence cs;
		int count = 0;
		for (int i = 0; i < Math.pow(2, 16); i++) {
			cs = padLeft(Integer.toBinaryString(i),16, '0');
			if (ordemBlocos.chars().average().equals(cs.chars().average())){
				String str = cs.toString().replaceAll("1", "#");

				for (int last = 0; last < list.size(); last++) {
					String strCopy = str;
					for (int j = 0; j < list.get(last).toString().length(); j++) {
						strCopy = strCopy.replaceFirst("#", list.get(last).toString().charAt(j) + "");
					}

					// Aqui montamos a versão nova desses objetos para o movimento X

					//System.out.println(str);

					String[][] puzzleCopy = puzzleCopy(this.puzzle); // Precisa ser copiado manualmente!
					String[][] movimentosValidosCopy = puzzleCopy(movimentosValidos); // Precisa ser copiado manualmente!
					String ordemBlocosCopy = ordemBlocos;

					// Aqui montamos a versão nova desses objetos para o movimento X


					List<Collection<Integer>> result = Collections.nCopies(1, Collections.emptyList());
					for (Collection<Integer> pool : Collections.nCopies(r, new LinkedHashSet<>(a))) {
						List<Collection<Integer>> temp = new ArrayList<>();
						for (Collection<Integer> x : result) {
							for (Integer elemento : pool) {
								Collection<Integer> z = new ArrayList<>(x);
								z.add(elemento);
								temp.add(z);
								// A partir daqui, é gerado um sucessor de diferente ordenação de tubos
								if (z.size() == r) {
									String[][] movimentosValidosTurno = puzzleCopy(movimentosValidos); // Precisa ser copiado manualmente!
									for (Integer k : z) {
										boolean next = true;
										for (int v = 0; v < 4 & next; v++) {
											for (int j = 0; j < 4 & next; j++) {
												if (Integer.parseInt(movimentosValidosTurno[v][j]) >= 2 & Integer.parseInt(movimentosValidosTurno[v][j]) <= 3) {
													movimentosValidosTurno[v][j] = "0"; // Indica que a peça já foi movimentada nessa rodada
													puzzleCopy[v][j] = rotateBlock(puzzleCopy[v][j], k);
													next = false; // Faz a quebra do laço
												}
											}
										}
									}
									Teste sucessor = new Teste(puzzleCopy, movimentosValidosCopy, ordemBlocosCopy);
									suc.add(sucessor);
									count++;
									break;
								}
							}
							break;
						}
						result = temp;
					}
				}
			}
		}
		//System.out.println(count);
		return suc;
	}







	while (rotacao != Math.pow(r, r)) {

    			cs = padLeft(Integer.toBinaryString(movements), 16, '0');
    			boolean movimentoValido = ordemBlocos.chars().average().equals(cs.chars().average());
    			while (!movimentoValido) {
    				movements++;
    				cs = padLeft(Integer.toBinaryString(movements), 16, '0');
    				movimentoValido = ordemBlocos.chars().average().equals(cs.chars().average());
    			}

    			String str = cs.toString().replaceAll("1", "#");
    			for (int last = 0; last < list.size(); last++) {
    				String strCopy = str;
    				for (int j = 0; j < list.get(last).toString().length(); j++) {
    					strCopy = strCopy.replaceFirst("#", list.get(last).toString().charAt(j) + "");
    				}

    				boolean validOrder = true;
    				strCopy = applyMask(strCopy, movementMask);
    				if (!(mediaDeBlocos == strCopy.chars().average().getAsDouble())) {
    					validOrder = false;
    				}

    				// Cria um bloco novo, com a nova rotação

    				if (validOrder) {
    					String state = padLeft(Integer.toString(Integer.parseInt(Integer.toString(rotacao), 10), 4), r, '0');
    					String[][] puzzleNovo = applyRotations(blockPool, strCopy, state);
    					if (puzzleIsConexo(puzzleNovo)) {

    						String csAux = padLeft(Integer.toBinaryString(movements), 16, '0');
    						boolean movimentoValidoAux = ordemBlocos.chars().average().equals(csAux.chars().average());
    						while (!movimentoValidoAux) {
    							movements++;
    							cs = padLeft(Integer.toBinaryString(movements), 16, '0');
    							movimentoValidoAux = ordemBlocos.chars().average().equals(cs.chars().average());
    						}

    						int auxMovements = movements;

    						ConnectMeEstado sucessor;
    						sucessor = new ConnectMeEstado(puzzle, movimentosValidos, ordemBlocos, (movements + 1), puzzleNovo);
    						suc.add(sucessor);
    					} else {
    						movements++;
    						break;
    					}
    				}
    			}
    			rotacao++;
    		}

    		return suc;

    	}